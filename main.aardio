import win.ui;
import win.ui.menu;
/*DSG{{*/
mainForm = win.form(text="Unofficial_Z_Access";right=757;bottom=467)
mainForm.add()
/*}}*/

var HostResolverLine="";
var QUICLine="";
var HostLine="";
var CMDLine='--host-resolver-rules="MAP bu2021.xyz 172.64.145.17:443,MAP annas-archive.se 172.64.145.17:443,MAP www.proxyium.com 172.64.145.17:443" -origin-to-force-quic-on=bu2021.xyz:443,annas-archive.se:443,www.proxyium.com:443 --host-rules="MAP libgen.is 193.218.118.42,MAP libgen.rs 193.218.118.42,MAP zh.singlelogin.re 176.123.7.105,MAP singlelogin.re 176.123.7.105" --ignore-certificate-errors';
//var url="https://zh.z-library.se/";

import wsock.tcp.simpleHttpServer; 
var url="/web/index.html";

if(_ARGV["c"]) 
{
	import fsys.file;
	
	var cfg;
	if(_ARGV["c"]!="")
		cfg=fsys.file(_ARGV["c"]);
	else
		cfg=fsys.file("CMDconfig.txt");
	if(!fsys.file.is(cfg))
	{
		win.msgboxErr("No Config File! ","ERROR!");
		return;
	}
	CMDLine=cfg.read();
	cfg.close();
}
if(_ARGV["d"])
{
	HostResolverLine="";
	QUICLine="";
	import fsys.file;
	var cfg;
	if(_ARGV["d"]!="")
		cfg=fsys.file(_ARGV["d"]);
	else
		cfg=fsys.file("DOMAINconfig.txt");
	if(!fsys.file.is(cfg))
	{
		win.msgboxErr("No Config File! ","ERROR!");
		return;
	}

	while(1)
	{
		var IP=cfg.read();
		var d=IP;
		while(1)
		{
			d=cfg.read();
			if(d=="") break 1;
			else if(!d) break 2;
			
			if(string.unpack(d,1,1)==string.unpack("^"))
			{
				d=string.slice(d,2,-1,true);
				HostLine=HostLine+"MAP "+d+" "+IP+",";
			}
			else
			{
				HostResolverLine=HostResolverLine+"MAP "+d+" "+IP+":443,";
				QUICLine=QUICLine+d+":443,";
			}
		}	
	}
	
	cfg.close();
	
	if(HostResolverLine!="") HostResolverLine=string.slice(HostResolverLine,1,-2,true);
	if(QUICLine!="") QUICLine=string.slice(QUICLine,1,-2,true);
	if(HostLine!="") HostLine=string.slice(HostLine,1,-2,true);
	
	CMDLine="";
	if(HostResolverLine!="") CMDLine=CMDLine+'--host-resolver-rules="'+HostResolverLine+'" ';
	if(QUICLine!="") CMDLine=CMDLine+'-origin-to-force-quic-on='+QUICLine+' ';
	if(HostLine!="") CMDLine=CMDLine+'--host-rules="'+HostLine+'" --ignore-certificate-errors ';
	
	if(CMDLine!="") CMDLine=string.slice(CMDLine,1,-2,true);
}
if(_ARGV["g"]) url=_ARGV["g"];
if(_ARGV["h"])
{
	url="/help.html";
}

import web.view.7;

if(string.len(CMDLine)>=8192) win.msgbox("Too long CMDLine, and this may cause Error. ","Warning");
var view=web.view(mainForm,0,CMDLine);
view.go("/web/index.html");

mainForm.show();
if(_ARGV["o"])
{
	//shit mountain code
	view.html="<!doctype html><html><head></head><body><p>"+CMDLine+'</p><a href="'+wsock.tcp.simpleHttpServer.startUrl()+'">&#x4e3b&#x9875</a></body></html>';
}
else if(_ARGV["a"])
{
	var AndroidLine=CMDLine;
	var ReplaceTable={
		['"'] = "\"+'"'
	};
	AndroidLine=string.replace(AndroidLine,".|:",ReplaceTable);
	AndroidLine='echo "_'+" "+AndroidLine+'" > chrome-command-line';
	view.html="<!doctype html><html><head></head><body><p>"+AndroidLine+'</p><a href="'+wsock.tcp.simpleHttpServer.startUrl()+'">&#x4e3b&#x9875</a></body></html>';
}
else view.go(url);
return win.loopMessage();

/* You may need: 
// from: https://chromium.googlesource.com/chromium/src/+/refs/heads/main/components/network_session_configurator/common/network_switch_list.h
// Copyright 2017 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
// This file deliberately has no header guard, as it's inlined in a number of
// files.
// no-include-guard-because-multiply-included
// Disables the QUIC protocol.
NETWORK_SWITCH(kDisableQuic, "disable-quic")
// Disables the HTTP/2 protocol.
NETWORK_SWITCH(kDisableHttp2, "disable-http2")
// Enables Alternate-Protocol when the port is user controlled (> 1024).
NETWORK_SWITCH(kEnableUserAlternateProtocolPorts,
               "enable-user-controlled-alternate-protocol-ports")
// Enables the QUIC protocol.  This is a temporary testing flag.
NETWORK_SWITCH(kEnableQuic, "enable-quic")
// Ignores certificate-related errors.
NETWORK_SWITCH(kIgnoreCertificateErrors, "ignore-certificate-errors")
// Specifies a comma separated list of host-port pairs to force use of QUIC on.
NETWORK_SWITCH(kOriginToForceQuicOn, "origin-to-force-quic-on")
// Disables known-root checks for outgoing WebTransport connections.
NETWORK_SWITCH(kWebTransportDeveloperMode, "webtransport-developer-mode")
// Specifies a comma separated list of QUIC connection options to send to
// the server.
NETWORK_SWITCH(kQuicConnectionOptions, "quic-connection-options")
// Specifies a comma separated list of QUIC client connection options.
NETWORK_SWITCH(kQuicClientConnectionOptions, "quic-client-connection-options")
// Specifies the maximum length for a QUIC packet.
NETWORK_SWITCH(kQuicMaxPacketLength, "quic-max-packet-length")
// Specifies the version of QUIC to use.
NETWORK_SWITCH(kQuicVersion, "quic-version")
// Allows for forcing socket connections to http/https to use fixed ports.
NETWORK_SWITCH(kTestingFixedHttpPort, "testing-fixed-http-port")
NETWORK_SWITCH(kTestingFixedHttpsPort, "testing-fixed-https-port")
// Comma-separated list of rules that control how hostnames are mapped.
//
// For example:
//    "MAP * 127.0.0.1" --> Forces all hostnames to be mapped to 127.0.0.1
//    "MAP *.google.com proxy" --> Forces all google.com subdomains to be
//                                 resolved to "proxy".
//    "MAP test.com [::1]:77 --> Forces "test.com" to resolve to IPv6 loopback.
//                               Will also force the port of the resulting
//                               socket address to be 77.
//    "MAP * baz, EXCLUDE www.google.com" --> Remaps everything to "baz",
//                                            except for "www.google.com".
//
// These mappings apply to the endpoint host in a net::URLRequest (the TCP
// connect and host resolver in a direct connection, and the CONNECT in an http
// proxy connection, and the endpoint host in a SOCKS proxy connection).
//
// TODO(mmenke): Can we just remove this?  host-resolver-rules is more generally
// useful.
NETWORK_SWITCH(kHostRules, "host-rules")
// Enable "greasing" HTTP/2 frame types, that is, sending frames of reserved
// types.  See https://tools.ietf.org/html/draft-bishop-httpbis-grease-00 for
// more detail.
NETWORK_SWITCH(kHttp2GreaseFrameType, "http2-grease-frame-type")
// If request has no body, close the stream not by setting END_STREAM flag on
// the HEADERS frame, but by sending an empty DATA frame with END_STREAM
// afterwards.  Only affects HTTP/2 request streams, not proxy or bidirectional
// streams.
NETWORK_SWITCH(kHttp2EndStreamWithDataFrame, "http2-end-stream-with-data-frame")

*/